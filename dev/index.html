<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · Homogenization.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Homogenization.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Tutorial</a><ul class="internal"><li><a class="toctext" href="#Base-mesh-1">Base mesh</a></li><li><a class="toctext" href="#Solving-a-&quot;coarse&quot;-FEM-problem-1">Solving a &quot;coarse&quot; FEM problem</a></li><li><a class="toctext" href="#Implicit-refinement-1">Implicit refinement</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Tutorial</a></li></ul><a class="edit-page" href="https://github.com/haampie/Homogenization.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Homogenization.jl-1" href="#Homogenization.jl-1">Homogenization.jl</a></h1><p>Consider the problem <span>$-\nabla \cdot a(x) \nabla u + \lambda u = f$</span> in 2D and 3D where <span>$a$</span> is a symmetric, positive definite matrix with piecewise constant coefficients in the domain <span>$U \subset \mathbb{R}^{d}$</span> with <span>$d = 2, 3,$</span> <span>$\lambda &gt; 0$</span> and <span>$u = 0$</span> on <span>$\partial U$</span>.</p><h2><a class="nav-anchor" id="Base-mesh-1" href="#Base-mesh-1">Base mesh</a></h2><p>We will assume it is feasible to make a triangulation of <span>$U$</span> such that <span>$a$</span> is constant on each triangle or tetrahedron. For this we need a mesh</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homogenization.Mesh" href="#Homogenization.Mesh"><code>Homogenization.Mesh</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Mesh(nodes, elements) -&gt; Mesh{dim,N,Tv,Ti}</code></pre><p>Stores the FEM mesh where the spatial dimension is <code>dim</code>, the number of nodes per element is <code>N</code>, the number type is <code>Tv</code> and the integer type <code>Ti</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">using StaticArrays
nodes = SVector{3,Float64}[(0,0,0),(1,0,0),(0,1,0),(1,1,0),(0,0,1),(1,0,1),(0,1,1),(1,1,1)]
elements = [(1,2,3,5),(2,3,4,8),(3,5,7,8),(2,5,6,8),(2,3,5,8)]
cube = Mesh(nodes, elements)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/haampie/Homogenization.jl/blob/9383bb854e206d0c5ca19bc14022ecd9472e2c8a/src/grid.jl#L3-L18">source</a></section><p>There are some helper functions as well to generate a simple mesh</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homogenization.hypercube" href="#Homogenization.hypercube"><code>Homogenization.hypercube</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hypercube(Tet{Float64}, n, Ti = Int; scale = 1, origin = (1,1,1), sorted = true) -&gt; Mesh</code></pre><p>Create a mesh of <code>n</code> by <code>n</code> by <code>n</code> cubes each split into 5 tetrahedra.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haampie/Homogenization.jl/blob/9383bb854e206d0c5ca19bc14022ecd9472e2c8a/src/tet/generate_grid.jl#L1-L5">source</a><div><div><pre><code class="language-none">hypercube(Tri{Float64}, n, Ti = Int; scale = 1, origin = (1,1,1), sorted = true) -&gt; Mesh</code></pre><p>Create a mesh of <code>n</code> by <code>n</code> squares each split into two triangles.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haampie/Homogenization.jl/blob/9383bb854e206d0c5ca19bc14022ecd9472e2c8a/src/tri/generate_grid.jl#L1-L5">source</a></section><p>Now we generate random conductivity parameters for each element of the base mesh.</p><pre><code class="language-julia">using Homogenization
using Homogenization: conductivity_per_element, generate_conductivity

n = 32
base = hypercube(Tri{Float64}, n)
a = conductivity_per_element(base, generate_conductivity(base, n))</code></pre><p>Next we could try to visualize the base mesh by exporting it to a file compatible with <a href="https://www.paraview.org/">Paraview</a>. We store the value of <code>a</code> as vectorial data for each element of the base mesh:</p><pre><code class="language-julia">using WriteVTK
using Homogenization: dimension
vtk_grid(&quot;checkerboard&quot;, base) do vtk
    as_matrix = reshape(reinterpret(Float64, a), dimension(base), :)
    vtk_cell_data(vtk, as_matrix, &quot;a&quot;)
end</code></pre><p>which saves a file <code>checkerboard.vtu</code> in the current working directory. It should look like</p><p><img src="paraview.png" alt="Paraview screenshot"/></p><h2><a class="nav-anchor" id="Solving-a-&quot;coarse&quot;-FEM-problem-1" href="#Solving-a-&quot;coarse&quot;-FEM-problem-1">Solving a &quot;coarse&quot; FEM problem</a></h2><p>For the moment let&#39;s stick to a very coarse grid for the checkerboard as we have it with just four nodes on the corners of each checkerboard cell (one node per cell). The weak form reads </p><div>\[\int_U a \nabla u \cdot \nabla v + \lambda uv = \int fv.\]</div><p>for <span>$u, v$</span> in the appropriate space, which we discretize by taking piece-wise linear elements for <span>$u$</span> and <span>$v.$</span> Let&#39;s take <span>$f = \lambda = 1.$</span></p><p>This is done as follows:</p><pre><code class="language-julia">using Homogenization: assemble_checkerboard, assemble_vector
A = assemble_checkerboard(base, a, 1.0)
b = assemble_vector(base, identity)</code></pre><p>The above does not take into account that <span>$u$</span> is supposed to be zero at the boundary. To impose the boundary condition we have to detect the boundary in the mesh first.  This is rather simple:</p><pre><code class="language-julia">using Homogenization: list_interior_nodes
interior = list_interior_nodes(base)</code></pre><p>The boundary condition is simply imposed by partitioning the unknowns <span>$x = \begin{bmatrix}x_i &amp; x_b\end{bmatrix}^T$</span> such that the linear system reads:</p><div>\[\begin{bmatrix}A_{ii} &amp; A_{ib} \\ A_{bi} &amp; A_{bb}\end{bmatrix}\begin{bmatrix}x_i \\ x_b\end{bmatrix} = \begin{bmatrix}b_i \\ b_b\end{bmatrix}.\]</div><p>With the boundary nodes <span>$x_b = 0$</span> this comes down to solving <span>$A_{ii}x_i = b_i:$</span></p><pre><code class="language-julia">using Homogenization: nnodes
A_int = A[interior, interior]
b_int = b[interior]
x_int = A_int \ b_int
x = zeros(nnodes(base))
x[interior] .= x_int</code></pre><p>Finally we would like to visualize the FEM solution in Paraview, which is done as follows:</p><pre><code class="language-julia">vtk_grid(&quot;checkerboard&quot;, base) do vtk
    as_matrix = reshape(reinterpret(Float64, a), dimension(base), :)
    vtk_cell_data(vtk, as_matrix, &quot;a&quot;)
    vtk_point_data(vtk, x, &quot;x&quot;)
end</code></pre><p>And it will look more or less like</p><p><img src="solution.png" alt="Paraview solution"/></p><h2><a class="nav-anchor" id="Implicit-refinement-1" href="#Implicit-refinement-1">Implicit refinement</a></h2><p>The coarse FEM problem will have a large error as the coefficients are rough and the number of nodes per checkerboard cell is approximately one. Therefore we wish to do <span>$h$</span>-refinement. The assumption will be that we will not be able to store the fully refined grid (nodes and elements) and neither the corresponding discrete operator (<code>A_int</code>).</p><p>It makes sense to try multigrid to get <span>$h$</span>-refinement</p><footer><hr/></footer></article></body></html>
