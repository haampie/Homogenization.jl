<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · Homogenization.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Homogenization.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Tutorial</a><ul class="internal"><li><a class="toctext" href="#Base-mesh-1">Base mesh</a></li><li><a class="toctext" href="#Solving-a-&quot;coarse&quot;-FEM-problem-1">Solving a &quot;coarse&quot; FEM problem</a></li><li><a class="toctext" href="#Implicit-refinement-1">Implicit refinement</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Tutorial</a></li></ul><a class="edit-page" href="https://github.com/haampie/Homogenization.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Homogenization.jl-1" href="#Homogenization.jl-1">Homogenization.jl</a></h1><p>Consider the problem <span>$-\nabla \cdot a(x) \nabla u + \lambda u = f$</span> in 2D and 3D where <span>$a$</span> is a symmetric, positive definite matrix with piecewise constant coefficients in the domain <span>$U \subset \mathbb{R}^{d}$</span> with <span>$d = 2, 3,$</span> <span>$\lambda &gt; 0$</span> and <span>$u = 0$</span> on <span>$\partial U$</span>.</p><h2><a class="nav-anchor" id="Base-mesh-1" href="#Base-mesh-1">Base mesh</a></h2><p>We will assume it is feasible to make a triangulation of <span>$U$</span> such that <span>$a$</span> is constant on each triangle or tetrahedron. For this we need a mesh</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homogenization.Mesh" href="#Homogenization.Mesh"><code>Homogenization.Mesh</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Mesh(nodes, elements) -&gt; Mesh{dim,N,Tv,Ti}</code></pre><p>Stores the FEM mesh where the spatial dimension is <code>dim</code>, the number of nodes per element is <code>N</code>, the number type is <code>Tv</code> and the integer type <code>Ti</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">using StaticArrays
nodes = SVector{3,Float64}[(0,0,0),(1,0,0),(0,1,0),(1,1,0),(0,0,1),(1,0,1),(0,1,1),(1,1,1)]
elements = [(1,2,3,5),(2,3,4,8),(3,5,7,8),(2,5,6,8),(2,3,5,8)]
cube = Mesh(nodes, elements)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/haampie/Homogenization.jl/blob/4ae7d09460232ef36400bb4f528aba2dd50ed7d7/src/grid.jl#L3-L18">source</a></section><p>There are some helper functions as well to generate a simple mesh</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homogenization.hypercube" href="#Homogenization.hypercube"><code>Homogenization.hypercube</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hypercube(Tet{Float64}, n, Ti = Int; scale = 1, origin = (1,1,1), sorted = true) -&gt; Mesh</code></pre><p>Create a mesh of <code>n</code> by <code>n</code> by <code>n</code> cubes each split into 5 tetrahedra.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haampie/Homogenization.jl/blob/4ae7d09460232ef36400bb4f528aba2dd50ed7d7/src/tet/generate_grid.jl#L1-L5">source</a><div><div><pre><code class="language-none">hypercube(Tri{Float64}, n, Ti = Int; scale = 1, origin = (1,1,1), sorted = true) -&gt; Mesh</code></pre><p>Create a mesh of <code>n</code> by <code>n</code> squares each split into two triangles.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haampie/Homogenization.jl/blob/4ae7d09460232ef36400bb4f528aba2dd50ed7d7/src/tri/generate_grid.jl#L1-L5">source</a></section><p>Now we generate random conductivity parameters for each element of the base mesh.</p><pre><code class="language-julia">using Homogenization
using Homogenization: conductivity_per_element, generate_conductivity

n = 32
base = hypercube(Tri{Float64}, n)
a = conductivity_per_element(base, generate_conductivity(base, n))</code></pre><p>Next we could try to visualize the base mesh by exporting it to a file compatible with <a href="https://www.paraview.org/">Paraview</a>. We store the value of <code>a</code> as vectorial data for each element of the base mesh:</p><pre><code class="language-julia">using WriteVTK
using Homogenization: dimension
vtk_grid(&quot;checkerboard&quot;, base) do vtk
    as_matrix = reshape(reinterpret(Float64, a), dimension(base), :)
    vtk_cell_data(vtk, as_matrix, &quot;a&quot;)
end</code></pre><p>which saves a file <code>checkerboard.vtu</code> in the current working directory. It should look like</p><p><img src="paraview.png" alt="Paraview screenshot"/></p><h2><a class="nav-anchor" id="Solving-a-&quot;coarse&quot;-FEM-problem-1" href="#Solving-a-&quot;coarse&quot;-FEM-problem-1">Solving a &quot;coarse&quot; FEM problem</a></h2><p>For the moment let&#39;s stick to a very coarse grid for the checkerboard as we have it with just four nodes on the corners of each checkerboard cell (one node per cell). The weak form reads </p><div>\[\int_U a \nabla u \cdot \nabla v + \lambda uv = \int fv.\]</div><p>for <span>$u, v$</span> in the appropriate space, which we discretize by taking piece-wise linear elements for <span>$u$</span> and <span>$v.$</span> Let&#39;s take <span>$f = \lambda = 1.$</span></p><p>This is done as follows:</p><pre><code class="language-julia">using Homogenization: assemble_checkerboard, assemble_vector
A = assemble_checkerboard(base, a, 1.0)
b = assemble_vector(base, identity)</code></pre><p>The above does not take into account that <span>$u$</span> is supposed to be zero at the boundary. To impose the boundary condition we have to detect the boundary in the mesh first.  This is rather simple:</p><pre><code class="language-julia">using Homogenization: list_interior_nodes
interior = list_interior_nodes(base)</code></pre><p>The boundary condition is simply imposed by partitioning the unknowns <span>$x = \begin{bmatrix}x_i &amp; x_b\end{bmatrix}^T$</span> such that the linear system reads:</p><div>\[\begin{bmatrix}A_{ii} &amp; A_{ib} \\ A_{bi} &amp; A_{bb}\end{bmatrix}\begin{bmatrix}x_i \\ x_b\end{bmatrix} = \begin{bmatrix}b_i \\ b_b\end{bmatrix}.\]</div><p>With the boundary nodes <span>$x_b = 0$</span> this comes down to solving <span>$A_{ii}x_i = b_i:$</span></p><pre><code class="language-julia">using Homogenization: nnodes
A_int = A[interior, interior]
b_int = b[interior]
x_int = A_int \ b_int
x = zeros(nnodes(base))
x[interior] .= x_int</code></pre><p>Finally we would like to visualize the FEM solution in Paraview, which is done as follows:</p><pre><code class="language-julia">vtk_grid(&quot;checkerboard&quot;, base) do vtk
    as_matrix = reshape(reinterpret(Float64, a), dimension(base), :)
    vtk_cell_data(vtk, as_matrix, &quot;a&quot;)
    vtk_point_data(vtk, x, &quot;x&quot;)
end</code></pre><p>And it will look more or less like</p><p><img src="solution.png" alt="Paraview solution"/></p><h2><a class="nav-anchor" id="Implicit-refinement-1" href="#Implicit-refinement-1">Implicit refinement</a></h2><p>The coarse FEM problem will have a large error as the coefficients are rough and the number of nodes per checkerboard cell is approximately one. Therefore we wish to do <span>$h$</span>-refinement. The assumption will be that we will not be able to store the fully refined grid (nodes and elements) and neither the corresponding discrete operator (<code>A</code>).</p><p>The usual solution is then to use an iterative method to solve <code>A * x = b</code> and compute the entries of the discrete operator <code>A</code>  on demand (matrix-free). However, in our case the coefficients of <span>$a$</span> are supposed to be constant in each refined element, so we can do better. We refine a single reference triangle or tetrahedron, build local discrete operators and then map the refined reference element to each base mesh element.</p><h3><a class="nav-anchor" id="Reusing-discrete-operators-of-a-single-reference-element-1" href="#Reusing-discrete-operators-of-a-single-reference-element-1">Reusing discrete operators of a single reference element</a></h3><p><img src="implicit.png" alt="Implicit grid"/></p><p>Suppose <span>$\tau \subset U$</span> is a single element of the base mesh. We refine <span>$\tau$</span> such that it has <span>$N_f$</span> nodes. A local discretized operator takes the form</p><div>\[A_{ij}^\tau = \int_\tau a \nabla \phi_i \cdot \nabla \phi_j \, dx\]</div><p>where <span>$\phi_i$</span> and <span>$\phi_j$</span> are local basis functions (<span>$i, j = 1, \dots, N_f$</span>) and <span>$a$</span> is a constant matrix by assumption. If we have some reference triangle or tetrahederon <span>$\hat{\tau},$</span> the pullback to reference coordinates looks like</p><div>\[A_{ij}^\tau = \int_\hat{\tau} a J^{-1}\nabla \hat{\phi}_i \cdot J^{-1}\nabla \hat{\phi}_j |J| \, d\hat{x}\]</div><p>where <span>$\hat{\phi}_i$</span> and <span>$\hat{\phi}_j$</span> are the corresponding reference basis functions and <span>$J$</span> is some matrix rotating and scaling the triangle or tetrahedron.</p><p>If we assume each base mesh element is refined the same way, then the only dependence on <span>$\tau$</span> is in <span>$J$</span> and the matrix <span>$a$</span>. We can save some computational work by computing <span>$d^2$</span> matrices</p><div>\[\hat{A}_{ij}^{(k,\ell)} := \int_\hat{\tau}\frac{\partial \phi_i}{\partial \hat{x}_k}\frac{\partial \phi_j}{\partial \hat{x}_\ell} \, d\hat{x} \text{ for } i, j = 1, \dots, N_f\]</div><p>for <span>$k, \ell = 1, \dots, d.$</span> This way the local operator <span>$A^\tau$</span> takes the form</p><div>\[A^\tau = \sum_{k, \ell = 1}^d (J^{-T}aJ^{-1}|J|)_{k,\ell}\hat{A}^{(k,\ell)}.\]</div><p>So practically, for any base element <span>$\tau,$</span> if we wish to work with the matrix <span>$A^\tau$</span>, we compute the mapping <span>$J$</span> and the tiny matrix <span>$J^{-T}aJ^{-1}|J|,$</span> and then reuse the matrices <span>$\hat{A}^{(k,\ell)}$</span> which we have computed up front once and for all.</p><h3><a class="nav-anchor" id="Implicit-grid-and-multigrid-(high-level-idea)-1" href="#Implicit-grid-and-multigrid-(high-level-idea)-1">Implicit grid &amp; multigrid (high-level idea)</a></h3><p>Let&#39;s refine the base grid <span>$r$</span> times, so that we have <span>$r + 1$</span> levels; level 1 has no refinements at all. We need a few things:</p><ol><li><p>Suppose the base mesh has <span>$N_e$</span> elements, and for a given level the refined reference element has <span>$N_f$</span> nodes. For convenient numbering we store nodes on the boundary of a base mesh element multiple times, so a good way to represent the right-hand side <span>$b$</span> and uknowns <span>$x$</span> is a matrix of size <span>$N_f \times N_e$</span>.</p></li><li><p>Not only do we need to build the matrices <span>$\hat{A}^{(k, \ell)}$</span>, also do we have to build interpolation operators from level <span>$k$</span> to <span>$k + 1$</span>. These will just be sparse matrices and we just need one on each level of the refined reference element.</p></li><li><p>To apply a &quot;global&quot; matrix-vector product with a discretized operator <span>$A$</span>, we will apply all local operators, which is sufficient for interior nodes of each base mesh element, but for nodes on the boundary of a base mesh element we have to make the data flow and sum the local values together.</p></li><li><p>We have to apply the Dirichlet zero boundary condition by zeroing out nodes on the boundary after multiplication.</p></li><li><p>Restricting a function from level <span>$k + 1$</span> to <span>$k$</span> is a completely local operation, but interpolating from <span>$k$</span> to <span>$k+1$</span> also requires summing values along the boundaries of all base mesh elements.</p></li></ol><p>We want to accomplish 3, 4 and 5 without storing a global list of connectivity data (i.e. lists of nodes that coincide globally) cause that would run into excessive storage demands again. Rather it is done via a couple sparse mappings solely on the base mesh:</p><ul><li>From each node to each element (and its local node number);</li><li>From each edge to each element (and its local edge number);</li><li>From each face to each element (and its local face number) (only in 3D)</li></ul><p>together with a local pre-computed listing of nodes on corners, the interior of edges and interior of faces of a simplex.</p><h3><a class="nav-anchor" id="Putting-this-into-action-1" href="#Putting-this-into-action-1">Putting this into action</a></h3><p>Let&#39;s build the above idea in code.</p><p>First we create a base mesh, which is the coarsest mesh of multigrid:</p><pre><code class="language-julia">using SparseArrays, LinearAlgebra
using Homogenization: generate_conductivity, conductivity_per_element, 
                      list_interior_nodes, assemble_checkerboard,
                      nnodes, BaseLevel

elementtype = Tri{Float64} # or Tet{Float64}
n = 32
base = hypercube(elementtype, n)
a = conductivity_per_element(base, generate_conductivity(base, n))
λ = 1.0
interior = list_interior_nodes(base)
F = cholesky(assemble_checkerboard(base, a, λ)[interior,interior])
base_level = BaseLevel(Float64, F, nnodes(base), interior)</code></pre><p><code>BaseLevel</code> stores a factorized version of the coarse operator and also allocates a vector <code>b</code> and <code>b_intererior</code>. It has all data to efficiently solve a coarse problem with a direct method (it does not pre-allocate a vector <code>x</code> for technical reasons).</p><p>Now we start working on the implicit grid. We construct many of the things of the previous section in a single call:</p><pre><code class="language-julia">using Homogenization: ImplicitFineGrid
refinements = 3
implicit = ImplicitFineGrid(base, refinements)</code></pre><p>In the REPL this will print a bit of information about the implicit grid, e.g.:</p><pre><code class="language-julia">julia&gt; implicit
Implicit grid of cell type Tri{Float64}. Base mesh has 1089 nodes and 2048 elements. Finest level (3) has 15 nodes and 16 elements. In total at most 30720 unknowns.</code></pre><p>It reads &quot;In total <em>at most</em> 30720 unknowns&quot; since this is the product <span>$N_e * N_f = 2048 * 15$</span> where nodes on the boundaries of the base mesh are counted multiple times. (The level numbering in the message might be off by one – it&#39;s the grid after the third refinement).</p><p>The <code>ImplicitFineGrid</code> type collects a lot of things:</p><pre><code class="language-julia">julia&gt; implicit.base # refernece to the base mesh
julia&gt; implicit.interfaces.nodes # sparse map from nodes -&gt; connected element + local id
julia&gt; implicit.interfaces.edges # sparse map from edges -&gt; connected element + local id
julia&gt; implicit.interfaces.faces # sparse map from faces -&gt; connected element + local id
julia&gt; implicit.reference.interops # array of interpolation operators from level to level
julia&gt; implicit.reference.numbering # local numbering of corners, edge and face nodes
julia&gt; implicit.reference.levels # mesh for each level of the refined reference element</code></pre><p>Next, to be able to impose the boundary condition we have to have sparse mappings from the nodes, edges and faces of base mesh elements touching the boundary:</p><pre><code class="language-julia">using Homogenization: list_boundary_nodes_edges_faces, ZeroDirichletConstraint
nodes, edges, faces = list_boundary_nodes_edges_faces(implicit.base)
constraint = ZeroDirichletConstraint(nodes, edges, faces)</code></pre><p>Finally we can build the <span>$A^{(k,\ell)}$</span> operators:</p><pre><code class="language-julia">using Homogenization: build_local_diffusion_operators, build_local_mass_matrices,
                      L2PlusDivAGrad
diff_terms = build_local_diffusion_operators(implicit.reference)
mass_terms = build_local_mass_matrices(implicit.reference)
level_operators = map(zip(diff_terms, mass_terms)) do op
    diff, mass = op
    L2PlusDivAGrad(diff, mass, constraint, λ, a)
end</code></pre><p>So <code>level_operators</code> is now an array of these operators for each level of the grid. It has all the values it needs: the value of <span>$\lambda$</span>, the conductivity <span>$a$</span> per base mesh element and the information to zero out boundary nodes.</p><p>Next, we allocate the vectors we need for multigrid (for convenience we shape them as matrices as explained above).</p><pre><code class="language-julia">using Homogenization: LevelState, refined_mesh, nelements, nnodes, base_mesh
level_states = map(1 : refinements) do i
    mesh = refined_mesh(implicit, i)
    LevelState(nelements(base_mesh(implicit)), nnodes(mesh), Float64)
end</code></pre><p>A <code>LevelState</code> contains just the arrays we need: an approximation to the unknown <code>x</code>, a right-hand side <code>b</code>, and a residual <code>r</code>. We have to have these vectors on every level. These are the only arrays that have a large memory footprint, so that&#39;s why we allocate them once and for all!</p><pre><code class="language-julia">julia&gt; size(level_states[end].x)
(15, 2048)</code></pre><p>Finally we have to set up the problem. We still have to set up a right-hand side. The right-hand should be constructed <em>locally</em>. For instance:</p><pre><code class="language-julia">using Homogenization: local_rhs!
finest_level = level_states[end]
local_rhs!(finest_level.b, implicit) # integrate v dx locally</code></pre><p>Note that <code>local_rhs!</code> does not accept a functional currently, but this function is very simle and can be written by the user basically. Currently it is just hard-coded to use <span>$f = 1$</span>.</p><p>Then, we take an initial guess <span>$x$</span>, this vector should be constructed <em>globally</em> and should satisfy the boundary condition:</p><pre><code class="language-julia">using Homogenization: broadcast_interfaces!, apply_constraint!
using Random
rand!(finest_level.x) # local values
broadcast_interfaces!(finest_level.x, implicit, refinements) # sum boundaries
apply_constraint!(finest_level.x, refinements, constraint, implicit) # impose b.c.</code></pre><p>Our initial guess resides in <code>finest_level.x</code> and should of course be nonzero</p><pre><code class="language-julia">julia&gt; finest_level.x
15×2048 Array{Float64,2}:
...</code></pre><p>Now we can run multigrid iterations:</p><pre><code class="language-julia">using Homogenization: vcycle!, zero_out_all_but_one!

ωs = [.02,.02,.02,.02] # constants in Richardson iteration / smoothing step per level
smoothing_steps = 1

for i = 1 : 100
    vcycle!(implicit, base_level, level_operators, level_states, ωs, refinements, smoothing_steps)

    zero_out_all_but_one!(finest_level.r, implicit, refinements)
    @info &quot;After cycle $i&quot; norm(finest_level.r)
end</code></pre><p>Unfortunately some constants are chosen by hand currently :(. Running this, the output should be something like:</p><pre><code class="language-julia">...
┌ Info: After cycle 98
└   norm(finest_level.r) = 0.0005182895775368055
┌ Info: After cycle 99
└   norm(finest_level.r) = 0.00047190444233626385
┌ Info: After cycle 100
└   norm(finest_level.r) = 0.00042970384073489823</code></pre><p>Note that computing the norm is done with a hack: we zero out all values of repeated nodes and then take the Euclidean norm.</p><p>Finally, we might wish to see what the approximate solution looks like. In our case we can still easily store the full grid as the problem is rather small, but in real applications we might not be able to export the full grid. </p><p>What we can do quite easily is to extract the approximate solution on a certain level. We have to select the values of <code>x</code> on the finest grid, but only those that appear on a coarser level. Fortunately by convention upon refinement new implicit nodes are appended to the back to the nodes array, which means that we can just extract the first so-many rows of <code>x</code> if we want to have the approximate solution on a coarser grid.</p><p>For example:</p><pre><code class="language-julia">using Homogenization: construct_full_grid, nnodes, refined_mesh
using WriteVTK 

# Construct a full mesh compatible with Paraview (nodes are repeated here as well!)
save = 2
full_mesh = construct_full_grid(implicit, save)

vtk_grid(&quot;checkerboard_solution&quot;, full_mesh) do vtk
    x_on_level = reshape(finest_level.x[1 : nnodes(refined_mesh(implicit, save)), :], :)
    vtk_point_data(vtk, x_on_level, &quot;x&quot;)
end</code></pre><p>It saves the file <code>checkerboard_solution.vtu</code> and should roughly look like</p><p><img src="mg_solution.png" alt="Multigrid solution"/></p><p>where we look at level <code>2</code> with a single refinement.</p><footer><hr/></footer></article></body></html>
