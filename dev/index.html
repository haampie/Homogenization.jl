<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · Homogenization.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Homogenization.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Tutorial</a><ul class="internal"><li><a class="toctext" href="#Base-mesh-1">Base mesh</a></li><li><a class="toctext" href="#Implicit-refinement-1">Implicit refinement</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Tutorial</a></li></ul><a class="edit-page" href="https://github.com/haampie/Homogenization.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Homogenization.jl-1" href="#Homogenization.jl-1">Homogenization.jl</a></h1><p>Consider the problem <span>$-\nabla \cdot a(x) \nabla u + \lambda u = f$</span> in 2D and 3D where <span>$a$</span> is a symmetric matrix with piecewise constant coefficients in the domain <span>$U \subset \mathbb{R}^{d}$</span> with <span>$d = 2, 3$</span>.</p><h2><a class="nav-anchor" id="Base-mesh-1" href="#Base-mesh-1">Base mesh</a></h2><p>We will assume it is feasible to make a triangulation of <span>$U$</span> such that <span>$a$</span> is constant on each triangle or tetrahedron. For this we need a mesh</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homogenization.Mesh" href="#Homogenization.Mesh"><code>Homogenization.Mesh</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Mesh(nodes, elements) -&gt; Mesh{dim,N,Tv,Ti}</code></pre><p>Stores the FEM mesh where the spatial dimension is <code>dim</code>, the number of nodes per element is <code>N</code>, the number type is <code>Tv</code> and the integer type <code>Ti</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">using StaticArrays
nodes = SVector{3,Float64}[(0,0,0),(1,0,0),(0,1,0),(1,1,0),(0,0,1),(1,0,1),(0,1,1),(1,1,1)]
elements = [(1,2,3,5),(2,3,4,8),(3,5,7,8),(2,5,6,8),(2,3,5,8)]
cube = Mesh(nodes, elements)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/haampie/Homogenization.jl/blob/f1ec2ca10fb409923aea4f53f74204609d31102c/src/grid.jl#L3-L18">source</a></section><p>There are some helper functions as well to generate a simple mesh</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Homogenization.hypercube" href="#Homogenization.hypercube"><code>Homogenization.hypercube</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">hypercube(Tet{Float64}, n, Ti = Int; scale = 1, origin = (1,1,1), sorted = true) -&gt; Mesh</code></pre><p>Create a mesh of <code>n</code> by <code>n</code> by <code>n</code> cubes each split into 5 tetrahedra.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haampie/Homogenization.jl/blob/f1ec2ca10fb409923aea4f53f74204609d31102c/src/tet/generate_grid.jl#L1-L5">source</a><div><div><pre><code class="language-none">hypercube(Tri{Float64}, n, Ti = Int; scale = 1, origin = (1,1,1), sorted = true) -&gt; Mesh</code></pre><p>Create a mesh of <code>n</code> by <code>n</code> squares each split into two triangles.</p></div></div><a class="source-link" target="_blank" href="https://github.com/haampie/Homogenization.jl/blob/f1ec2ca10fb409923aea4f53f74204609d31102c/src/tri/generate_grid.jl#L1-L5">source</a></section><p>Now we generate random conductivity parameters for each element of the base mesh.</p><pre><code class="language-julia">using Homogenization
using Homogenization: conductivity_per_element, generate_conductivity

n = 32
base = hypercube(Tri{Float64}, n)
a = conductivity_per_element(base, generate_conductivity(base, n))</code></pre><p>Next we could try to visualize the base mesh by exporting it to a file compatible with <a href="https://www.paraview.org/">Paraview</a>. We store the value of <code>a</code> as vectorial data for each element of the base mesh:</p><pre><code class="language-julia">using WriteVTK
using Homogenization: dimension
vtk_grid(&quot;checkerboard&quot;, base) do vtk
    as_matrix = reshape(reinterpret(Float64, a), dimension(base), :)
    vtk_cell_data(vtk, as_matrix, &quot;a&quot;)
end</code></pre><p>which saves a file <code>checkerboard.vtu</code> in the current working directory. It should look like</p><p><img src="paraview.png" alt="Paraview screenshot"/></p><h2><a class="nav-anchor" id="Implicit-refinement-1" href="#Implicit-refinement-1">Implicit refinement</a></h2><p>In FEM we wish to do <span>$h$</span>-refinement of this triangulation, but the fully refined grid is assumed to be too large to store explicitly.</p><footer><hr/></footer></article></body></html>
